/**
 * fibonacci_heap.c
 *
 * =============================================================================
 * Теория и реализация: Фибоначчиева приоритетная очередь (Fibonacci Heap)
 * =============================================================================
 *
 * СОДЕРЖАНИЕ
 * ----------
 * 1. Приоритетные очереди и эволюция структур
 * 2. Почему появилась фибоначчиева куча
 * 3. Структура фибоначчиевой кучи
 * 4. Деревья общего вида и кольцевые списки
 * 5. Инварианты фибоначчиевой кучи
 * 6. Ленивые операции и амортизированный анализ
 * 7. Основные операции:
 *    - insert
 *    - find-min
 *    - merge (union)
 *    - delete-min
 * 8. Вычислительные сложности
 * 9. Реализация на языке C
 * 10. Практические замечания
 *
 * =============================================================================
 *
 * 1) Приоритетные очереди и эволюция структур
 *
 *    Приоритетная очередь поддерживает операции:
 *      - insert(x)
 *      - find-min / find-max
 *      - delete-min / delete-max
 *      - merge (слияние двух очередей)
 *
 *    Историческая эволюция:
 *
 *      Binary Heap      — простая, merge дорогой
 *      Leftist Heap     — быстрый merge
 *      Skew Heap        — ещё проще, амортизированно
 *      Binomial Heap    — строгая структура, O(log n)
 *      Fibonacci Heap   — экстремально быстрые вставки и слияния
 *
 * =============================================================================
 *
 * 2) Почему появилась фибоначчиева куча
 *
 *    Цель:
 *      - минимизировать стоимость операций insert и merge
 *
 *    Идея:
 *      - НЕ поддерживать строгую форму дерева сразу
 *      - разрешить "хаос"
 *      - восстанавливать порядок ТОЛЬКО при delete-min
 *
 *    Это приводит к:
 *      insert  → O(1)
 *      merge   → O(1)
 *      find-min → O(1)
 *
 *    Цена:
 *      - сложная структура
 *      - сложный амортизированный анализ
 *
 * =============================================================================
 *
 * 3) Структура фибоначчиевой кучи
 *
 *    Фибоначчиева куча состоит из:
 *
 *      - набора деревьев общего вида
 *      - корни деревьев объединены в КОЛЬЦЕВОЙ двусвязный список
 *
 *    Каждый узел хранит:
 *      - key       — значение (приоритет)
 *      - degree    — количество детей
 *      - parent    — указатель на родителя
 *      - child     — указатель на одного из детей
 *      - left/right — связи в кольцевом списке
 *      - marked    — флаг потери ребёнка (для decrease-key)
 *
 * =============================================================================
 *
 * 4) Кольцевой двусвязный список
 *
 *    Кольцевой список позволяет:
 *      - вставлять узлы за O(1)
 *      - удалять узлы за O(1)
 *      - легко объединять два списка
 *
 *    Каждый список:
 *      node->left->right == node
 *      node->right->left == node
 *
 * =============================================================================
 *
 * 5) Инварианты фибоначчиевой кучи
 *
 *    (1) Heap-свойство:
 *        key(parent) <= key(child)
 *
 *    (2) Корни образуют кольцевой список
 *
 *    (3) Строгой балансировки НЕТ
 *
 *    (4) Ограничение на степень узла:
 *        степень узла O(log n)
 *
 *        Это доказывается через числа Фибоначчи
 *
 * =============================================================================
 *
 * 6) Ленивые операции и амортизированный анализ
 *
 *    Основная идея:
 *      - insert и merge НЕ выполняют балансировку
 *      - балансировка выполняется при delete-min
 *
 *    Амортизированный анализ показывает:
 *      - insert: O(1)
 *      - merge:  O(1)
 *      - delete-min: O(log n)
 *
 * =============================================================================
 *
 * 7) Основные операции
 *
 *    insert(x):
 *      - создаём одноузловое дерево
 *      - добавляем в список корней
 *
 *    find-min:
 *      - указатель min хранится явно
 *
 *    merge(h1, h2):
 *      - объединяем два кольцевых списка
 *      - выбираем меньший min
 *
 *    delete-min:
 *      - удаляем минимальный корень
 *      - его детей добавляем в список корней
 *      - выполняем консолидацию
 *
 * =============================================================================
 *
 * 8) Вычислительные сложности
 *
 *    Амортизированно:
 *
 *      insert        — O(1)
 *      find-min      — O(1)
 *      merge         — O(1)
 *      delete-min    — O(log n)
 *
 *    Память:
 *      O(n)
 *
 * =============================================================================
 *
 * 9) Реализация на языке C
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <assert.h>

/* ============================================================================
 * Структуры данных
 * ============================================================================
 */

/* Узел фибоначчиевой кучи */
typedef struct FibNode {
    int key;                    /* значение */
    int degree;                 /* количество детей */
    int marked;                 /* потерял ли ребёнка */
    struct FibNode *parent;
    struct FibNode *child;
    struct FibNode *left;
    struct FibNode *right;
} FibNode;

/* Фибоначчиева куча */
typedef struct {
    FibNode *min;               /* указатель на минимум */
    int n;                      /* количество элементов */
} FibonacciHeap;

/* ============================================================================
 * Вспомогательные функции
 * ============================================================================
 */

/* Создание нового узла */
static FibNode *fib_new_node(int key) {
    FibNode *n = (FibNode *)malloc(sizeof(FibNode));
    if (!n) { perror("malloc"); exit(EXIT_FAILURE); }
    n->key = key;
    n->degree = 0;
    n->marked = 0;
    n->parent = n->child = NULL;
    n->left = n->right = n;   /* одиночное кольцо */
    return n;
}

/* Создание пустой кучи */
FibonacciHeap *fib_create(void) {
    FibonacciHeap *h = (FibonacciHeap *)malloc(sizeof(FibonacciHeap));
    if (!h) { perror("malloc"); exit(EXIT_FAILURE); }
    h->min = NULL;
    h->n = 0;
    return h;
}

/* ============================================================================
 * Основные операции
 * ============================================================================
 */

/**
 * fib_insert
 * ----------
 * Вставка элемента за O(1)
 */
void fib_insert(FibonacciHeap *h, int key) {
    FibNode *x = fib_new_node(key);

    if (!h->min) {
        h->min = x;
    } else {
        /* вставка в кольцевой список корней */
        x->right = h->min->right;
        x->left = h->min;
        h->min->right->left = x;
        h->min->right = x;
        if (x->key < h->min->key)
            h->min = x;
    }
    h->n++;
}

/**
 * fib_find_min
 * ------------
 * Поиск минимума за O(1)
 */
int fib_find_min(FibonacciHeap *h) {
    assert(h->min);
    return h->min->key;
}

/* ============================================================================
 * Внутренние операции (используются в delete-min)
 * ============================================================================
 */

/**
 * fib_link
 * --------
 * Делает y ребёнком x
 */
static void fib_link(FibNode *y, FibNode *x) {
    /* удалить y из списка корней */
    y->left->right = y->right;
    y->right->left = y->left;

    /* добавить y в список детей x */
    y->parent = x;
    if (!x->child) {
        x->child = y;
        y->left = y->right = y;
    } else {
        y->right = x->child->right;
        y->left = x->child;
        x->child->right->left = y;
        x->child->right = y;
    }

    x->degree++;
    y->marked = 0;
}

/**
 * fib_consolidate
 * ---------------
 * Консолидация деревьев одинаковой степени
 */
static void fib_consolidate(FibonacciHeap *h) {
    FibNode *A[64] = {0};

    FibNode *start = h->min;
    FibNode *w = start;
    if (!w) return;

    do {
        FibNode *x = w;
        int d = x->degree;
        w = w->right;

        while (A[d]) {
            FibNode *y = A[d];
            if (y->key < x->key) {
                FibNode *tmp = x; x = y; y = tmp;
            }
            fib_link(y, x);
            A[d++] = NULL;
        }
        A[d] = x;
    } while (w != start);

    h->min = NULL;

    for (int i = 0; i < 64; ++i) {
        if (A[i]) {
            if (!h->min) {
                h->min = A[i];
                h->min->left = h->min->right = h->min;
            } else {
                A[i]->right = h->min->right;
                A[i]->left = h->min;
                h->min->right->left = A[i];
                h->min->right = A[i];
                if (A[i]->key < h->min->key)
                    h->min = A[i];
            }
        }
    }
}

/**
 * fib_delete_min
 * --------------
 * Удаление минимума за O(log n) (амортизированно)
 */
void fib_delete_min(FibonacciHeap *h) {
    FibNode *z = h->min;
    if (!z) return;

    /* добавить детей z в список корней */
    if (z->child) {
        FibNode *c = z->child;
        do {
            FibNode *next = c->right;
            c->parent = NULL;

            c->left = h->min;
            c->right = h->min->right;
            h->min->right->left = c;
            h->min->right = c;

            c = next;
        } while (c != z->child);
    }

    /* удалить z из списка */
    z->left->right = z->right;
    z->right->left = z->left;

    if (z == z->right) {
        h->min = NULL;
    } else {
        h->min = z->right;
        fib_consolidate(h);
    }

    free(z);
    h->n--;
}
